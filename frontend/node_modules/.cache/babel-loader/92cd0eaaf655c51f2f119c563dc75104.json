{"ast":null,"code":"import{useRef,useEffect,useCallback}from'react';/**\r\n * Hook personalizado para manejar el foco en modales\r\n * Evita problemas de aria-hidden y asegura accesibilidad correcta\r\n */const useModalFocus=open=>{const modalRef=useRef(null);const previousActiveElement=useRef(null);// Guardar el elemento activo antes de abrir el modal\nuseEffect(()=>{if(open){previousActiveElement.current=document.activeElement;}},[open]);// Restaurar el foco al cerrar el modal\nconst handleClose=useCallback(()=>{// Asegurar que el foco se libere del modal\nif(modalRef.current){const activeElement=modalRef.current.querySelector(':focus');if(activeElement){activeElement.blur();}}// Pequeño delay para asegurar que el foco se libere completamente\nsetTimeout(()=>{// Restaurar el foco al elemento anterior si existe\nif(previousActiveElement.current&&previousActiveElement.current.focus&&document.contains(previousActiveElement.current)){previousActiveElement.current.focus();}else{var _document$activeEleme;// Si no hay elemento anterior válido, liberar el foco\n(_document$activeEleme=document.activeElement)===null||_document$activeEleme===void 0?void 0:_document$activeEleme.blur();}},0);},[]);// Manejar el evento onExited del Dialog\nconst handleExited=useCallback(()=>{var _document$activeEleme2;// Asegurar que el foco se libere completamente al cerrar\n(_document$activeEleme2=document.activeElement)===null||_document$activeEleme2===void 0?void 0:_document$activeEleme2.blur();// Limpiar la referencia del elemento anterior\npreviousActiveElement.current=null;},[]);return{modalRef,handleClose,handleExited};};export default useModalFocus;","map":null,"metadata":{},"sourceType":"module"}