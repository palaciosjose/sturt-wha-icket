# 0016-Asignaci√≥n de departamentos y Opciones Simple

## üìã **RESUMEN EJECUTIVO**

Este documento describe la implementaci√≥n del sistema de gesti√≥n de departamentos (colas) y sus opciones en Whaticket SaaS. El sistema permite crear departamentos y agregar opciones de chatbot que se guardan correctamente en la base de datos.

## üéØ **OBJETIVO**

Implementar un flujo de trabajo robusto para:
- ‚úÖ Crear departamentos con opciones de chatbot
- ‚úÖ Guardar opciones temporalmente durante la creaci√≥n
- ‚úÖ Persistir opciones cuando se guarda el departamento
- ‚úÖ Cargar opciones existentes al editar departamentos

## üèóÔ∏è **ARQUITECTURA DEL SISTEMA**

### **Componentes Principales:**

1. **`QueueModal`** - Modal para crear/editar departamentos
2. **`QueueOptions`** - Gesti√≥n de opciones de chatbot
3. **`QueueOptionStepper`** - Interfaz de opciones anidadas
4. **Backend Services** - API para persistencia de datos

### **Flujo de Datos:**
```
Frontend (React) ‚Üî API (Node.js) ‚Üî Database (MySQL)
```

## üîß **IMPLEMENTACI√ìN T√âCNICA**

### **1. Base de Datos**

#### **Tabla: `QueueOptions`**
```sql
CREATE TABLE QueueOptions (
  id INT PRIMARY KEY AUTO_INCREMENT,
  title VARCHAR(255) NOT NULL,
  message TEXT,
  option VARCHAR(50),
  queueId INT,
  parentId INT,
  transferQueueId INT,
  mediaPath VARCHAR(255),
  mediaName VARCHAR(255),
  createdAt TIMESTAMP,
  updatedAt TIMESTAMP,
  FOREIGN KEY (queueId) REFERENCES Queues(id),
  FOREIGN KEY (parentId) REFERENCES QueueOptions(id),
  FOREIGN KEY (transferQueueId) REFERENCES Queues(id)
);
```

#### **Migraci√≥n: `add-transfer-queue-to-queue-options.ts`**
```typescript
import { QueryInterface, DataTypes } from "sequelize";

module.exports = {
  up: (queryInterface: QueryInterface) => {
    return queryInterface.addColumn("QueueOptions", "transferQueueId", {
      type: DataTypes.INTEGER,
      allowNull: true,
      references: { model: "Queues", key: "id" },
      onUpdate: "CASCADE",
      onDelete: "SET NULL"
    });
  },
  down: (queryInterface: QueryInterface) => {
    return queryInterface.removeColumn("QueueOptions", "transferQueueId");
  }
};
```

### **2. Backend (Node.js + TypeScript)**

#### **Modelo: `QueueOption.ts`**
```typescript
@Table
class QueueOption extends Model<QueueOption> {
  @PrimaryKey
  @AutoIncrement
  @Column
  id: number;

  @Column
  title: string;

  @AllowNull
  @Column
  message: string;

  @AllowNull
  @Column
  option: string;

  @ForeignKey(() => Queue)
  @Column
  queueId: number;

  @ForeignKey(() => QueueOption)
  @Column
  parentId: number;

  @ForeignKey(() => Queue)
  @Column
  transferQueueId: number;

  @BelongsTo(() => Queue)
  queue: Queue;

  @BelongsTo(() => QueueOption, { foreignKey: 'parentId' })
  parent: QueueOption;

  @BelongsTo(() => Queue, { foreignKey: 'transferQueueId' })
  transferQueue: Queue;
}
```

#### **Servicio: `CreateService.ts`**
```typescript
const CreateService = async (queueOptionData: QueueOptionData): Promise<QueueOption> => {
  console.log("üîç CreateService - Datos recibidos:", queueOptionData);
  console.log("üîç CreateService - queueId:", queueOptionData.queueId);
  
  const queueOption = await QueueOption.create(queueOptionData);
  console.log("‚úÖ CreateService - Opci√≥n creada:", queueOption.toJSON());
  
  return queueOption;
};
```

#### **Servicio: `ListService.ts`**
```typescript
const ListService = async ({ queueId, queueOptionId, parentId }: QueueOptionFilter): Promise<QueueOption[]> => {
  console.log("üîç ListService - Par√°metros recibidos:", { queueId, queueOptionId, parentId });

  const whereOptions: WhereOptions = {};

  if (queueId) {
    whereOptions.queueId = queueId;
    console.log("üîç ListService - Agregando queueId al where:", queueId);
  }

  if (parentId == -1) {
    whereOptions.parentId = null;
    console.log("üîç ListService - Agregando parentId null al where");
  }

  const queueOptions = await QueueOption.findAll({
    where: whereOptions,
    include: [
      { model: Queue, as: 'queue' },
      { model: Queue, as: 'transferQueue', foreignKey: 'transferQueueId' }
    ],
    order: [["id", "ASC"]]
  });

  console.log("üîç ListService - Opciones encontradas:", queueOptions.length);
  return queueOptions;
};
```

### **3. Frontend (React + TypeScript)**

#### **Componente: `QueueOptions/index.js`**
```javascript
export const QueueOptions = forwardRef(({ queueId }, ref) => {
  const [options, setOptions] = useState([]);

  // ‚úÖ Cargar opciones existentes
  useEffect(() => {
    if (queueId) {
      const fetchOptions = async () => {
        try {
          const { data } = await api.request({
            url: "/queue-options",
            method: "GET",
            params: { queueId, parentId: -1 },
          });
          const optionList = data.map((option) => ({
            ...option,
            children: [],
            edition: false,
          }));
          setOptions(optionList);
        } catch (e) {
          toastError(e);
        }
      };
      fetchOptions();
    }
  }, []);

  // ‚úÖ Agregar nueva opci√≥n
  const addOption = () => {
    const newOption = {
      title: "",
      message: "",
      edition: false,
      option: options.length + 1,
      queueId: queueId || null, // ‚úÖ Permitir null temporalmente
      parentId: null,
      children: [],
    };
    setOptions([...options, newOption]);
  };

  // ‚úÖ Guardar opci√≥n individual
  const handleSave = async (option) => {
    try {
      // ‚úÖ Verificar que tengamos queueId v√°lido
      if (!queueId) {
        console.log("‚ö†Ô∏è No hay queueId - guardando temporalmente en memoria");
        option.edition = false;
        updateOptions();
        toastError("Opci√≥n guardada temporalmente. Guarde el departamento primero.");
        return;
      }
      
      // ‚úÖ Asegurar que tenga queueId
      if (!option.queueId) {
        option.queueId = queueId;
      }
      
      if (option.id) {
        await api.request({
          url: `/queue-options/${option.id}`,
          method: "PUT",
          data: option,
        });
      } else {
        const { data } = await api.request({
          url: `/queue-options`,
          method: "POST",
          data: option,
        });
        option.id = data.id;
      }
      
      option.edition = false;
      updateOptions();
      toastError("Opci√≥n guardada correctamente.");
    } catch (e) {
      toastError(e);
    }
  };

  // ‚úÖ Guardar todas las opciones temporales
  const saveAllOptions = useCallback(async (savedQueueId) => {
    console.log("üîÑ saveAllOptions - Guardando opciones temporales para queueId:", savedQueueId);
    
    for (let option of options) {
      if (!option.id && option.title.trim() !== "") {
        try {
          const { data } = await api.request({
            url: `/queue-options`,
            method: "POST",
            data: {
              ...option,
              queueId: savedQueueId
            },
          });
          option.id = data.id;
        } catch (e) {
          console.error("‚ùå Error al guardar opci√≥n temporal:", e);
        }
      }
    }
  }, [options]);

  // ‚úÖ Exponer funciones al componente padre
  useImperativeHandle(ref, () => ({
    saveAllOptions
  }));

  return (
    <div className={classes.root}>
      <Typography>
        {i18n.t("queueOptions.title")}
        <Button onClick={addOption} startIcon={<AddIcon />}>
          {i18n.t("queueOptions.add")}
        </Button>
      </Typography>
      {renderStepper()}
    </div>
  );
});
```

#### **Componente: `QueueModal/index.js`**
```javascript
const QueueModal = ({ open, onClose, queueId }) => {
  const queueOptionsRef = useRef();

  // ‚úÖ Guardar departamento y opciones
  const handleSaveQueue = async (values) => {
    try {
      let savedQueueId = queueId;
      
      // ‚úÖ GUARDAR DEPARTAMENTO
      if (queueId) {
        await api.put(`/queue/${queueId}`, {
          ...values, schedules, promptId: selectedPrompt ? selectedPrompt : null
        });
      } else {
        const { data } = await api.post("/queue", {
          ...values, schedules, promptId: selectedPrompt ? selectedPrompt : null
        });
        savedQueueId = data.id;
      }
      
      // ‚úÖ GUARDAR TODAS LAS OPCIONES TEMPORALES
      if (queueOptionsRef.current && queueOptionsRef.current.saveAllOptions) {
        await queueOptionsRef.current.saveAllOptions(savedQueueId);
      }
      
      toast.success(i18n.t("queues.success"));
      handleClose();
    } catch (err) {
      toastError(err);
    }
  };

  return (
    <Dialog open={open} onClose={handleClose}>
      <DialogTitle>
        {queueId ? "Editar cola" : "Agregar cola"}
      </DialogTitle>
      <DialogContent>
        <Formik initialValues={queue} onSubmit={handleSaveQueue}>
          <Form>
            {/* Campos del departamento */}
            <QueueOptions 
              queueId={queueId}
              ref={queueOptionsRef}
            />
            <DialogActions>
              <Button onClick={handleClose}>Cancelar</Button>
              <Button type="submit" color="primary">
                {queueId ? "Guardar" : "Agregar"}
              </Button>
            </DialogActions>
          </Form>
        </Formik>
      </DialogContent>
    </Dialog>
  );
};
```

## üîÑ **FLUJO DE TRABAJO DETALLADO**

### **ESCENARIO 1: Crear Nuevo Departamento**

#### **Paso 1: Abrir Modal**
```
Usuario ‚Üí Clic "AGREGAR DEPARTAMENTO"
‚Üí QueueModal se abre con queueId = undefined
‚Üí QueueOptions se inicializa sin queueId
```

#### **Paso 2: Agregar Opciones Temporales**
```
Usuario ‚Üí Clic "+ AGREGAR" en opciones
‚Üí addOption() se ejecuta con queueId = undefined
‚Üí Opci√≥n se crea con queueId: null
‚Üí Usuario escribe t√≠tulo y guarda
‚Üí handleSave() detecta queueId = undefined
‚Üí Opci√≥n se guarda temporalmente en memoria
```

#### **Paso 3: Guardar Departamento**
```
Usuario ‚Üí Llena datos del departamento
‚Üí Clic "AGREGAR" (bot√≥n del modal)
‚Üí handleSaveQueue() se ejecuta
‚Üí Departamento se guarda en backend
‚Üí Se obtiene savedQueueId = 33
‚Üí saveAllOptions(savedQueueId) se ejecuta
‚Üí Todas las opciones temporales se guardan con queueId = 33
```

#### **Paso 4: Carga de Opciones**
```
Modal se cierra y reabre
‚Üí useEffect se ejecuta con queueId = 33
‚Üí fetchOptions() carga opciones del backend
‚Üí Opciones se muestran correctamente
```

### **ESCENARIO 2: Editar Departamento Existente**

#### **Paso 1: Abrir Modal**
```
Usuario ‚Üí Clic "Editar" en departamento existente
‚Üí QueueModal se abre con queueId = 33
‚Üí QueueOptions se inicializa con queueId = 33
‚Üí useEffect ejecuta fetchOptions()
‚Üí Opciones existentes se cargan y muestran
```

#### **Paso 2: Agregar/Editar Opciones**
```
Usuario ‚Üí Agrega o edita opciones
‚Üí handleSave() detecta queueId = 33
‚Üí Opciones se guardan inmediatamente en backend
‚Üí Cambios se reflejan en tiempo real
```

## üìä **LOGS DE DEBUGGING**

### **Creaci√≥n de Nuevo Departamento:**
```
useEffect ejecutado - queueId: undefined
‚ûï addOption - queueId: undefined
‚ûï newOption creado: Object
üîç ANTES - option.queueId: null
üîç ANTES - queueId del componente: undefined
‚ö†Ô∏è No hay queueId - guardando temporalmente en memoria
üîÑ Guardando opciones temporales desde QueueModal...
üîÑ saveAllOptions - Guardando opciones temporales para queueId: 33
üíæ Guardando opci√≥n temporal: reclamo1
‚úÖ Opci√≥n temporal guardada con ID: 32
‚úÖ Todas las opciones temporales guardadas
üîÑ useEffect ejecutado - queueId: 33
üì° Cargando opciones para queueId: 33
üì• Opciones recibidas: Array(1)
‚úÖ Opciones procesadas: Array(1)
```

### **Edici√≥n de Departamento Existente:**
```
üîÑ useEffect ejecutado - queueId: 33
üì° Cargando opciones para queueId: 33
üì• Opciones recibidas: Array(1)
‚úÖ Opciones procesadas: Array(1)
üíæ Guardando opci√≥n: Object
üîç DESPU√âS - option.queueId: 33
üîÑ UPDATE opci√≥n existente ID: 32
‚úÖ Opci√≥n guardada correctamente
```

## üéØ **PUNTOS CLAVE DE LA IMPLEMENTACI√ìN**

### **1. Manejo de Estados Temporales**
- ‚úÖ **queueId = undefined**: Durante creaci√≥n de nuevo departamento
- ‚úÖ **queueId = null**: En opciones temporales
- ‚úÖ **queueId = number**: Cuando departamento ya existe

### **2. Guardado en Dos Fases**
- ‚úÖ **Fase 1**: Guardado temporal en memoria (sin queueId)
- ‚úÖ **Fase 2**: Guardado definitivo en base de datos (con queueId)

### **3. Comunicaci√≥n Entre Componentes**
- ‚úÖ **forwardRef**: Para exponer funciones de QueueOptions
- ‚úÖ **useImperativeHandle**: Para saveAllOptions
- ‚úÖ **useRef**: Para acceder desde QueueModal

### **4. Validaciones y Manejo de Errores**
- ‚úÖ **Verificaci√≥n de queueId**: Antes de guardar opciones
- ‚úÖ **Mensajes informativos**: Para guiar al usuario
- ‚úÖ **Logs detallados**: Para debugging

## üîß **CONFIGURACI√ìN DE DESARROLLO**

### **Variables de Entorno:**
```env
DB_DIALECT=mysql
DB_HOST=localhost
DB_PORT=3306
DB_NAME=waticket_saas
DB_USER=root
DB_PASS=
```

### **Dependencias Principales:**
```json
{
  "sequelize": "^6.x.x",
  "sequelize-typescript": "^3.x.x",
  "react": "^17.x.x",
  "formik": "^2.x.x",
  "material-ui": "^4.x.x"
}
```

### **Scripts de Desarrollo:**
```bash
# Backend
cd waticketsaas/backend
npm run build
npm start

# Frontend
cd waticketsaas/frontend
npm start
```

## üìù **NOTAS IMPORTANTES**

### **1. Migraciones**
- ‚úÖ **Ejecutar migraciones** antes de usar el sistema
- ‚úÖ **Verificar columnas** en base de datos
- ‚úÖ **Backup de datos** antes de cambios

### **2. Debugging**
- ‚úÖ **Logs detallados** en backend y frontend
- ‚úÖ **Verificaci√≥n de queueId** en cada operaci√≥n
- ‚úÖ **Manejo de errores** con try-catch

### **3. Experiencia de Usuario**
- ‚úÖ **Mensajes informativos** para guiar al usuario
- ‚úÖ **Guardado temporal** sin interrumpir flujo
- ‚úÖ **Carga autom√°tica** de opciones existentes

## üöÄ **PR√ìXIMOS PASOS**

Este sistema sienta las bases para implementar:
1. **Transferencias entre departamentos** (AI-driven)
2. **Opciones anidadas** (sub-opciones)
3. **Integraci√≥n con IA** para respuestas autom√°ticas
4. **Configuraci√≥n avanzada** de flujos de chatbot

---

**Documento creado:** 26-07-2025  
**Versi√≥n:** 1.0  
**Autor:** Sistema de IA  
**Estado:** Implementado y Funcionando ‚úÖ 